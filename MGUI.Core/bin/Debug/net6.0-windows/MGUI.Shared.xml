<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MGUI.Shared</name>
    </assembly>
    <members>
        <member name="M:MGUI.Shared.Helpers.ContentUtils.GetTexture(Microsoft.Xna.Framework.Content.ContentManager,System.String)">
            <param name="TexturePath">The full path, starting from but not including the Root 'Content'folder.
            <para/>This path should not contain the file extension.<para/>
            EX: @"TileSets\Environment\set1"</param>
            <returns></returns>
        </member>
        <member name="M:MGUI.Shared.Helpers.EnumUtils.GetDescription(System.Enum)">
            <summary>Returns the description attribute of this Enum value</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.EnumUtils.GetDataMemberName(System.Enum)">
            <summary>Returns the Name property value of the DataMember attribute applied to the given enum value, or null if the enum value does not have a DataMember attribute applied to it.</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MGUI.Shared.Helpers.EnumUtils.ParseEnumOrNullFromDataMemberName``1(System.String)">
            <summary>Attempts to parse the given string <paramref name="value"/> to the given <typeparamref name="TEnum"/>, 
            comparing against the 'DataMember' attribute name of each enum value, rather than using .ToString() on the enum value.<para/>
            Returns null if no match is found.</summary>
            <typeparam name="TEnum"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MGUI.Shared.Helpers.FloatRange.GetLength">
            <summary>You may want to add 1 to this value, such as when working with screen pixels<para/>
            (I.E. if a range goes from 5 to 5, it would usually be considered a length of 1 when working in screen space, as it occupies 1 pixel. But this function would treat it as length=0)</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.FloatRange.SignedDistance(MGUI.Shared.Helpers.FloatRange)">
            <summary>Computes the distance between this <see cref="T:MGUI.Shared.Helpers.FloatRange"/> and the <paramref name="Other"/> <see cref="T:MGUI.Shared.Helpers.FloatRange"/></summary>
            <returns>A negative value if the ranges overlap. Positive value if they don't overlap. Zero if they are touching along the edge.</returns>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.PackInts(System.Int32,System.Int32)">
            <summary>Packs 2 ints into 1 long via bitwise operations. To go from 1 long back to 2 ints, use <see cref="M:MGUI.Shared.Helpers.GeneralUtils.UnpackInts(System.Int64)"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.UnpackInts(System.Int64)">
            <summary>Unpacks 2 ints from 1 long via bitwise operations. To go from 2 ints back to 1 long, use <see cref="M:MGUI.Shared.Helpers.GeneralUtils.PackInts(System.Int32,System.Int32)"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.GetPermutations``1(System.Collections.Generic.IList{``0})">
            <summary>Returns every possible permutation pair of elements in this <see cref="T:System.Collections.Generic.IList`1"/> (order matters, I.E. Permutation(1, 2) is not the same as Permutation(2, 1))</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.NextPowerOf2(System.Single)">
            <summary>Returns a power of 2 whose value is >= the given <paramref name="Value"/>. Examples:<para/>
            <code>Input     Output<br/>
            31.9f       32<br/>
            32.0f       32<br/>
            32.1f       64<br/>
            200f        256</code></summary>
            <param name="Value"></param>
            <returns></returns>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.SelectConsecutivePairs``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>Enumerates every consecutive pair in <paramref name="this"/> enumerable.</summary>
            <param name="includeLastToFirst">If true, will attempt to pair the last element in <paramref name="this"/> with the first element in <paramref name="this"/>, 
            provided they are not the same element. (I.E. <paramref name="this"/>'s length is > 2)</param>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.GetTopleft(Microsoft.Xna.Framework.Vector2,MGUI.Shared.Helpers.RelativePosition,System.Drawing.SizeF)">
            <summary>Computes where the topleft position would be if the given <paramref name="Position"/> is at the given <see cref="T:MGUI.Shared.Helpers.RelativePosition"/> of an object with the given <paramref name="Size"/>.<para/>
            EX:<br/>Inputs: <paramref name="Position"/>=(5,20), <paramref name="Anchor"/>=<see cref="F:MGUI.Shared.Helpers.RelativePosition.MiddleRight"/>, <paramref name="Size"/>=(30, 22)<br/>
            Returns: (5,20)-(30,22/2)=(-25,9)</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.GetTopleft(Microsoft.Xna.Framework.Point,MGUI.Shared.Helpers.RelativePosition,MonoGame.Extended.Size)">
            <summary>Computes where the topleft position would be if the given <paramref name="Position"/> is at the given <see cref="T:MGUI.Shared.Helpers.RelativePosition"/> of an object with the given <paramref name="Size"/>.<para/>
            EX:<br/>Inputs: <paramref name="Position"/>=(5,20), <paramref name="Anchor"/>=<see cref="F:MGUI.Shared.Helpers.RelativePosition.MiddleRight"/>, <paramref name="Size"/>=(30, 22)<br/>
            Returns: (5,20)-(30,22/2)=(-25,9)</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.AsGroupsOfLength``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Groups the elements in <see cref="T:System.Collections.Generic.IEnumerable`1"/> into chunks of <paramref name="GroupLength"/> consecutive elements.<para/>
            Example:<br/>
            Input: { 20, 12, 16, 4, 55, 123, 17, 4 }, <paramref name="GroupLength"/>=3<br/>
            Output: { { 20, 12, 16 }, { 4, 55, 123 }, { 17, 4 } }</summary>
            <param name="GroupLength">How many elements should be in each group.</param>
        </member>
        <member name="M:MGUI.Shared.Helpers.GeneralUtils.ClearOneByOne``1(System.Collections.ObjectModel.ObservableCollection{``0})">
            <summary>This method is intended to replace the usage of <see cref="M:System.Collections.ObjectModel.Collection`1.Clear"/> on <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>s<br/> 
            because Clear does not include the old items that were removed in the <see cref="E:System.Collections.ObjectModel.ObservableCollection`1.CollectionChanged"/> event args.<para/>
            See also: <see href="https://stackoverflow.com/questions/224155/when-clearing-an-observablecollection-there-are-no-items-in-e-olditems"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.PointUtils.ToRectangle(Microsoft.Xna.Framework.Point,System.Int32)">
            <summary>Returns a <see cref="T:Microsoft.Xna.Framework.Rectangle"/> where the top-left corner is at this <see cref="T:Microsoft.Xna.Framework.Point"/> and with the given dimensions.</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.PointUtils.ToRectangle(Microsoft.Xna.Framework.Point,System.Int32,System.Int32)">
            <summary>Returns a <see cref="T:Microsoft.Xna.Framework.Rectangle"/> where the top-left corner is at this <see cref="T:Microsoft.Xna.Framework.Point"/> and with the given dimensions.</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetRectangle(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Coordinates are INCLUSIVE</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetRectangle(System.Single,System.Single,System.Single,System.Single)">
            <summary>Coordinates are INCLUSIVE</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetRectangle(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Coordinates are INCLUSIVE</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetRectangle(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>Coordinates are INCLUSIVE</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetRectangleF(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Coordinates are INCLUSIVE</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetRectangleF(System.Single,System.Single,System.Single,System.Single)">
            <summary>Coordinates are INCLUSIVE</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetRectangleF(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Coordinates are INCLUSIVE</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.RoundUp(MonoGame.Extended.RectangleF)">
            <summary>Returns a <see cref="T:Microsoft.Xna.Framework.Rectangle"/> that fully encloses the given <see cref="T:MonoGame.Extended.RectangleF"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.Union(System.Collections.Generic.IEnumerable{Microsoft.Xna.Framework.Rectangle})">
            <summary>Returns a <see cref="T:Microsoft.Xna.Framework.Rectangle"/> that fully spans all the given <paramref name="Inputs"/> <see cref="T:Microsoft.Xna.Framework.Rectangle"/>s.</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.Union(System.Collections.Generic.IEnumerable{MonoGame.Extended.RectangleF})">
            <summary>Returns a <see cref="T:MonoGame.Extended.RectangleF"/> that fully spans all the given <paramref name="Inputs"/> <see cref="T:MonoGame.Extended.RectangleF"/>s.</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetExpanded(Microsoft.Xna.Framework.Rectangle,System.Int32)">
            <summary>Returns a new <see cref="T:Microsoft.Xna.Framework.Rectangle"/> that is expanded on all sides by the given <paramref name="Amount"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetExpanded(Microsoft.Xna.Framework.Rectangle,MonoGame.Extended.Thickness)">
            <summary>Returns a new <see cref="T:Microsoft.Xna.Framework.Rectangle"/> that is expanded on each side by the given <paramref name="Amount"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetCompressed(Microsoft.Xna.Framework.Rectangle,System.Int32)">
            <summary>Returns a new <see cref="T:Microsoft.Xna.Framework.Rectangle"/> that is compressed on all sides by the given <paramref name="Amount"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetCompressed(Microsoft.Xna.Framework.Rectangle,MonoGame.Extended.Thickness)">
            <summary>Returns a new <see cref="T:Microsoft.Xna.Framework.Rectangle"/> that is compressed on each side by the given <paramref name="Amount"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetExpanded(MonoGame.Extended.RectangleF,System.Single)">
            <summary>Returns a new <see cref="T:MonoGame.Extended.RectangleF"/> that is expanded on all sides by the given <paramref name="Amount"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetExpanded(MonoGame.Extended.RectangleF,MonoGame.Extended.Thickness)">
            <summary>Returns a new <see cref="T:MonoGame.Extended.RectangleF"/> that is expanded on each side by the given <paramref name="Amount"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetCompressed(MonoGame.Extended.RectangleF,System.Single)">
            <summary>Returns a new <see cref="T:MonoGame.Extended.RectangleF"/> that is compressed on all sides by the given <paramref name="Amount"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RectangleUtils.GetCompressed(MonoGame.Extended.RectangleF,MonoGame.Extended.Thickness)">
            <summary>Returns a new <see cref="T:MonoGame.Extended.RectangleF"/> that is compressed on each side by the given <paramref name="Amount"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.RenderUtils.CreateRenderTarget(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Rectangle,System.Boolean)">
            <param name="PreserveContents">If true, the render target content will be preserved even if it is slow or requires extra memory.</param>
        </member>
        <member name="M:MGUI.Shared.Helpers.RenderUtils.CreateRenderTarget(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.Int32,System.Int32,System.Boolean)">
            <param name="PreserveContents">If true, the render target content will be preserved even if it is slow or requires extra memory.</param>
        </member>
        <member name="M:MGUI.Shared.Helpers.SizeUtils.AsPositive(MonoGame.Extended.Size)">
            <summary>Makes the sign of the width and height be positive via Math.Abs(...)</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.SizeUtils.Clamp(MonoGame.Extended.Size,MonoGame.Extended.Size,MonoGame.Extended.Size)">
            <summary>Clamps this <see cref="T:MonoGame.Extended.Size"/> to fit its Width and Height into the inclusive range specified by <paramref name="Min"/> and <paramref name="Max"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.SizeUtils.AsPositive(System.Drawing.SizeF)">
            <summary>Makes the sign of the width and height be positive via Math.Abs(...)</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.SizeUtils.Clamp(System.Drawing.SizeF,System.Drawing.SizeF,System.Drawing.SizeF)">
            <summary>Clamps this <see cref="T:System.Drawing.SizeF"/> to fit its Width and Height into the inclusive range specified by <paramref name="Min"/> and <paramref name="Max"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.StringUtils.SplitAndKeepDelimiters(System.String,System.Collections.Generic.IEnumerable{System.Char})">
            <summary>Splits this string by the given <paramref name="delimiters"/>, while keeping the delimited characters in the result set.<para/>
            <code>"Hello   World ".SplitAndKeepDelimiters(' ')<br/>[ "Hello", " ", " ", " ", "World", " " ]</code></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.StringUtils.SplitAndKeepDelimiters(System.String,System.Char[])">
            <summary>Splits this string by the given <paramref name="delimiters"/>, while keeping the delimited characters in the result set.<para/>
            <code>"Hello   World ".SplitAndKeepDelimiters(' ')<br/>[ "Hello", " ", " ", " ", "World", " " ]</code></summary>
        </member>
        <member name="T:MGUI.Shared.Helpers.TemporaryChange`1">
            <typeparam name="TItem">The type of item to modify</typeparam>
        </member>
        <member name="P:MGUI.Shared.Helpers.TemporaryChange`1.Previous">
            <summary>The value that <typeparamref name="TItem"/> will be reverted to when this object is disposed.</summary>
        </member>
        <member name="P:MGUI.Shared.Helpers.TemporaryChange`1.Temporary">
            <summary>The value that <typeparamref name="TItem"/> is temporarily changed to.</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.TemporaryChange`1.#ctor(`0,`0,System.Action{`0})">
            <param name="PreviousValue">The value that <typeparamref name="TItem"/> will be reverted to when this object is disposed.</param>
            <param name="TemporaryValue">The value that <typeparamref name="TItem"/> will be temporarily changed to.</param>
            <param name="SetValue">An action to invoke that changes <typeparamref name="TItem"/> to the new, temporary value.</param>
        </member>
        <member name="M:MGUI.Shared.Helpers.TemporaryChange`1.#ctor(`0,`0,System.Action{`0},System.Action{`0})">
            <param name="PreviousValue">The value that <typeparamref name="TItem"/> will be reverted to when this object is disposed.</param>
            <param name="TemporaryValue">The value that <typeparamref name="TItem"/> will be temporarily changed to.</param>
            <param name="SetValue">An action to invoke that changes <typeparamref name="TItem"/> to the new, temporary value.</param>
            <param name="RevertValue">An action to invoke that changes <typeparamref name="TItem"/> back to its previous value.</param>
        </member>
        <member name="T:MGUI.Shared.Helpers.TemporaryChange`2">
            <typeparam name="TItem">The type of item to modify</typeparam>
            <typeparam name="TParameter">An additional parameter used when modifying <typeparamref name="TItem"/></typeparam>
        </member>
        <member name="P:MGUI.Shared.Helpers.TemporaryChange`2.Previous">
            <summary>The value that <typeparamref name="TItem"/> will be reverted to when this object is disposed.</summary>
        </member>
        <member name="P:MGUI.Shared.Helpers.TemporaryChange`2.Temporary">
            <summary>The value that <typeparamref name="TItem"/> is temporarily changed to.</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.TemporaryChange`2.#ctor(`0,`0,`1,`1,System.Action{`0,`1})">
            <param name="PreviousValue">The value that <typeparamref name="TItem"/> will be reverted to when this object is disposed.</param>
            <param name="TemporaryValue">The value that <typeparamref name="TItem"/> will be temporarily changed to.</param>
            <param name="PreviousParameter">The parameter value to use when changing <typeparamref name="TItem"/> back to the <paramref name="PreviousValue"/></param>
            <param name="TemporaryParameter">The parameter value to use when changing <typeparamref name="TItem"/> to the temporary <paramref name="TemporaryValue"/></param>
            <param name="SetValue">An action to invoke that changes <typeparamref name="TItem"/> to a new value.</param>
        </member>
        <member name="T:MGUI.Shared.Helpers.SolidColorTexture">
            <summary>Creates a 1x1 pixel texture of a solid color</summary>
        </member>
        <member name="T:MGUI.Shared.Helpers.TextureUtils">
            <summary>This class is intended to help create custom textures on the fly</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.TextureUtils.GetDataAs2D(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>Retrieves the Texture data as a 2D Color array. Topleft is Color[0, 0]. Move right by 1 is Color[1, 0], Down by 1 is Color[0, 1].</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.TextureUtils.CreateCircleTexture(Microsoft.Xna.Framework.Graphics.SpriteBatch,System.Single,Microsoft.Xna.Framework.Color,System.Boolean)">
            <param name="disposeWithSpriteBatch">If true, the <see cref="T:Microsoft.Xna.Framework.Graphics.Texture2D"/> will be automatically disposed when <paramref name="sb"/> is disposed.</param>
        </member>
        <member name="M:MGUI.Shared.Helpers.TextureUtils.SaveToFile(Microsoft.Xna.Framework.Graphics.Texture2D,System.String)">
            <summary>Saves the given texture to a png.</summary>
            <param name="this">The texture to save</param>
            <param name="FilePath">The file path, with or without .png file extension</param>
        </member>
        <member name="M:MGUI.Shared.Helpers.ThicknessUtils.IsEmpty(MonoGame.Extended.Thickness)">
            <summary>Returns true if all sides are 0</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.ThicknessUtils.Clamp(MonoGame.Extended.Thickness,MonoGame.Extended.Size,MonoGame.Extended.Size)">
            <summary>Adjusts the total width and height of this <see cref="T:MonoGame.Extended.Thickness"/> to fit within the inclusive range [<paramref name="MinSize"/>, <paramref name="MaxSize"/>].<para/>
            If the width or height must be increased, the extra width or height is added to <see cref="P:MonoGame.Extended.Thickness.Left"/> / <see cref="P:MonoGame.Extended.Thickness.Top"/>.<br/>
            If the width or height must be decreased, the excess width or height is first removed from <see cref="P:MonoGame.Extended.Thickness.Right"/> / <see cref="P:MonoGame.Extended.Thickness.Bottom"/>, then from <see cref="P:MonoGame.Extended.Thickness.Left"/> / <see cref="P:MonoGame.Extended.Thickness.Top"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.ThicknessUtils.ClampWidth(MonoGame.Extended.Thickness,System.Int32,System.Int32)">
            <summary>Adjusts the total width of this <see cref="T:MonoGame.Extended.Thickness"/> to fit within the inclusive range [<paramref name="MinWidth"/>, <paramref name="MaxWidth"/>].<para/>
            If the width must be increased, extra width is added to <see cref="P:MonoGame.Extended.Thickness.Left"/>.<br/>
            If the width must be decreased, extra width is first removed from <see cref="P:MonoGame.Extended.Thickness.Right"/>, then from <see cref="P:MonoGame.Extended.Thickness.Left"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.ThicknessUtils.ClampHeight(MonoGame.Extended.Thickness,System.Int32,System.Int32)">
            <summary>Adjusts the total height of this <see cref="T:MonoGame.Extended.Thickness"/> to fit within the inclusive range [<paramref name="MinHeight"/>, <paramref name="MaxHeight"/>].<para/>
            If the height must be increased, extra height is added to <see cref="P:MonoGame.Extended.Thickness.Top"/>.<br/>
            If the height must be decreased, extra height is first removed from <see cref="P:MonoGame.Extended.Thickness.Bottom"/>, then from <see cref="P:MonoGame.Extended.Thickness.Top"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.VectorUtils.AngleBetween(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>AngleBetween - the angle between 2 vectors</summary>
            <returns>Returns the the angle in degrees between vector1 and vector2 (from -180 to 180)</returns>
        </member>
        <member name="M:MGUI.Shared.Helpers.VectorUtils.Perpendicular(Microsoft.Xna.Framework.Vector2)">
            <summary>Returns an orthogonal <see cref="T:Microsoft.Xna.Framework.Vector2"/> by rotating this <see cref="T:Microsoft.Xna.Framework.Vector2"/> 90 degrees clockwise (right normal)<para/>
            See also: <see cref="M:MGUI.Shared.Helpers.VectorUtils.LeftNormal(Microsoft.Xna.Framework.Vector2)"/>, <see cref="M:MGUI.Shared.Helpers.VectorUtils.RightNormal(Microsoft.Xna.Framework.Vector2)"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.VectorUtils.LeftNormal(Microsoft.Xna.Framework.Vector2)">
            <summary>Returns an orthogonal <see cref="T:Microsoft.Xna.Framework.Vector2"/> by rotating this <see cref="T:Microsoft.Xna.Framework.Vector2"/> 90 degrees counter clockwise (left normal)</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.VectorUtils.RightNormal(Microsoft.Xna.Framework.Vector2)">
            <summary>Returns an orthogonal <see cref="T:Microsoft.Xna.Framework.Vector2"/> by rotating this <see cref="T:Microsoft.Xna.Framework.Vector2"/> 90 degrees clockwise (right normal)</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.VectorUtils.IsAlmostEqualDirection(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Double)">
            <summary>Returns true if the two vectors point in almost the same direction. I.E. one vector is a scalar multiple of the other</summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.VectorUtils.GetSignedDistance(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>Returns the distance from the given <paramref name="Point"/> to a line with the given <paramref name="LineDirection"/> and passing through the given <paramref name="LinePoint"/>.<para/>
            Returns a negative value if the <paramref name="Point"/> is below the line (I.E. on the side of the line that the <paramref name="Normal"/> does not point towards)</summary>
            <param name="Normal">A <see cref="T:Microsoft.Xna.Framework.Vector2"/> that is orthogonal to the <paramref name="LineDirection"/>, and indicates which side of the <paramref name="LineDirection"/> is 'above'.</param>
        </member>
        <member name="M:MGUI.Shared.Helpers.ViewModelBase.NPC(System.String)">
            <summary>Notify Property Changed for the given <paramref name="PropertyName"/></summary>
        </member>
        <member name="M:MGUI.Shared.Helpers.ViewModelBase.AutoNPC(System.String)">
            <summary>Parameter <paramref name="PropertyName"/> is optional. If not specified, <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/> is automatically applied by the compiler. (Do not pass in null)</summary>
            <param name="PropertyName"></param>
        </member>
        <member name="M:MGUI.Shared.Input.HandledByEventArgs`1.SetHandled``1(``0,System.Boolean)">
            <summary>Deprecated - use <see cref="M:MGUI.Shared.Input.HandledByEventArgs`1.SetHandledBy``1(``0,System.Boolean)"/> instead.</summary>
        </member>
        <member name="M:MGUI.Shared.Input.HandledByEventArgs`1.Reset">
            <summary>Resets <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> and <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.HandledBy"/> back to their default values.<br/>
            (<see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/>=false, <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.HandledBy"/>=default)</summary>
        </member>
        <member name="M:MGUI.Shared.Input.InputTracker.Update(MGUI.Shared.Rendering.UpdateBaseArgs)">
            <summary>Should be invoked exactly once per Update tick, at the very start of your Game's Update method.<para/>
            This method will detect changes to the mouse/keyboard states but won't fire the events until <see cref="M:MGUI.Shared.Input.Mouse.MouseTracker.UpdateHandlers"/> or <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.UpdateHandlers"/> are called.</summary>
        </member>
        <member name="T:MGUI.Shared.Input.Keyboard.KeyboardHandler">
            <summary>Exposes several keyboard-related events that you can subscribe and respond to, such as <see cref="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Pressed"/>, <see cref="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Released"/>, <see cref="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Clicked"/>.<para/>
            This class is instantiated via: <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.CreateHandler``1(``0,System.Nullable{System.Double},System.Boolean,System.Boolean)"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Keyboard.KeyboardHandler.AlwaysHandlesEvents">
            <summary>If true, <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.HandledBy"/> will always be set to <see cref="P:MGUI.Shared.Input.Keyboard.KeyboardHandler.Owner"/> after invoking an event.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Keyboard.KeyboardHandler.InvokeEvenIfHandled">
            <summary>If true, events will still be invoked even if <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> is true.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Pressed">
            <summary>Invoked immediately after a Key has been pressed.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Released">
            <summary>Invoked immediately after a Key has been released.<para/>
            Note: This event is invoked before <see cref="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Clicked"/></summary>
        </member>
        <member name="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Clicked">
            <summary>Invoked immediately after a Key has been clicked.<para/>
            Note: This event is invoked after <see cref="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Released"/></summary>
        </member>
        <member name="M:MGUI.Shared.Input.Keyboard.KeyboardHandler.AutoUpdate">
            <summary>Should only be invoked via <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.UpdateHandlers"/></summary>
        </member>
        <member name="M:MGUI.Shared.Input.Keyboard.KeyboardHandler.ManualUpdate">
            <summary>Should be invoked exactly once per Update tick, but only on <see cref="T:MGUI.Shared.Input.Keyboard.KeyboardHandler"/>s where <see cref="P:MGUI.Shared.Input.Keyboard.KeyboardHandler.IsManualUpdate"/> is true.<para/>
            This method will invoke any pending keyboard events.</summary>
        </member>
        <member name="M:MGUI.Shared.Input.Keyboard.KeyboardHandler.Unsubscribe">
            <summary>Permanently invalidates this <see cref="T:MGUI.Shared.Input.Keyboard.KeyboardHandler"/> so that it will not receive and invoke any further keyboard-related events.</summary>
        </member>
        <member name="T:MGUI.Shared.Input.Keyboard.KeyboardTracker">
            <summary>Detects changes to the keyboard state between the previous and current Update ticks, but does not invoke the events. Instead, events are subscribed to and fired by <see cref="T:MGUI.Shared.Input.Keyboard.KeyboardHandler"/>.<br/>
            See: <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.CreateHandler``1(``0,System.Nullable{System.Double},System.Boolean,System.Boolean)"/>, <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.CreateHandler``1(``0,MGUI.Shared.Input.InputUpdatePriority,System.Boolean,System.Boolean)"/><para/>
            This class is automatically instantiated when creating an instance of <see cref="P:MGUI.Shared.Input.Keyboard.KeyboardTracker.InputTracker"/>. See: <see cref="P:MGUI.Shared.Input.InputTracker.Keyboard"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Keyboard.KeyboardTracker.ClickTimeThreshold">
            <summary>The maximum amount of time that can pass between a key press and key release 
            to still be registed as a Click event (<see cref="E:MGUI.Shared.Input.Keyboard.KeyboardHandler.Clicked"/>)</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Keyboard.KeyboardTracker.Handlers">
            <summary>To create a <see cref="T:MGUI.Shared.Input.Keyboard.KeyboardHandler"/>, use <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.CreateHandler``1(``0,System.Nullable{System.Double},System.Boolean,System.Boolean)"/> or <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.CreateHandler``1(``0,MGUI.Shared.Input.InputUpdatePriority,System.Boolean,System.Boolean)"/></summary>
        </member>
        <member name="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.CreateHandler``1(``0,MGUI.Shared.Input.InputUpdatePriority,System.Boolean,System.Boolean)">
            <param name="UpdatePriority">The priority with which the handler receives keyboard events. A higher priority means this handler will have the first chance to receive and handle events.</param>
            <param name="AlwaysHandlesEvents">If true, the handler will always set <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.HandledBy"/> to <paramref name="Owner"/> when receiving the keyboard event.</param>
            <param name="InvokeEvenIfHandled">If true, the handler will still receive the keyboard event even if <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> is true.</param>
        </member>
        <member name="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.CreateHandler``1(``0,System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <param name="UpdatePriority">The priority with which the handler receives keyboard events. A higher priority means this handler will have the first chance to receive and handle events.<para/>
            If null, the caller is expected to manually call <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardHandler.ManualUpdate"/> themselves.<br/>
            If not null, <see cref="M:MGUI.Shared.Input.Keyboard.KeyboardHandler.AutoUpdate"/> will automatically be invoked when updating this <see cref="T:MGUI.Shared.Input.Keyboard.KeyboardTracker"/><para/>
            Minimum Value = 0. Maximum Value = 100. Recommended to use preset values from <see cref="T:MGUI.Shared.Input.InputUpdatePriority"/>.</param>
            <param name="AlwaysHandlesEvents">If true, the handler will always set <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.HandledBy"/> to <paramref name="Owner"/> when receiving the keyboard event.</param>
            <param name="InvokeEvenIfHandled">If true, the handler will still receive the keyboard event even if <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> is true.</param>
        </member>
        <member name="F:MGUI.Shared.Input.Keyboard.KeyboardTracker.RecentKeyPressedEvents">
            <summary>The most recent Key Press events that have occurred, even if they occurred on a prior Update tick. These values are set back to null when the key is released.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Keyboard.KeyboardTracker.CurrentKeyPressedEvents">
            <summary>The Key Press events that occurred on the current Update tick, or null if the key wasn't just pressed on the current Update tick.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Keyboard.KeyboardTracker.CurrentKeyReleasedEvents">
            <summary>The Key Release events that occurred on the current Update tick, or null if the key wasn't just released on the current Update tick.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Keyboard.KeyboardTracker.CurrentKeyClickedEvents">
            <summary>The Key click events that occurred on the current Update tick, or null if the key wasn't just clicked on the current Update tick.</summary>
        </member>
        <member name="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.UpdateHandlers">
            <summary>Should be invoked exactly once per Update tick.<para/>
            This method will invoke any pending keyboard events on its <see cref="P:MGUI.Shared.Input.Keyboard.KeyboardTracker.Handlers"/> where <see cref="P:MGUI.Shared.Input.Keyboard.KeyboardHandler.IsManualUpdate"/> is false.</summary>
        </member>
        <member name="M:MGUI.Shared.Input.Keyboard.KeyboardTracker.KeyToTextInputString(Microsoft.Xna.Framework.Input.Keys,System.String,System.String,System.String)">
            <param name="EnterValue">Note: Windows typically uses "\r\n", Mac '\r', Linux '\n'.</param>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMousePressedEventArgs.IsLMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMousePressedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMousePressedEventArgs.IsRMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMousePressedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMousePressedEventArgs.IsMMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMousePressedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseReleasedEventArgs.IsLMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseReleasedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseReleasedEventArgs.IsRMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseReleasedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseReleasedEventArgs.IsMMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseReleasedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseClickedEventArgs.IsLMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseClickedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseClickedEventArgs.IsRMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseClickedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseClickedEventArgs.IsMMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseClickedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDragStartEventArgs.IsLMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDragStartEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDragStartEventArgs.IsRMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDragStartEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDragStartEventArgs.IsMMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDragStartEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDraggedEventArgs.IsLMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDraggedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDraggedEventArgs.IsRMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDraggedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDraggedEventArgs.IsMMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDraggedEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/></summary>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.BaseMouseDraggedEventArgs.GetTotalDistanceMoved(System.Boolean)">
            <summary>Returns the distance the mouse has moved from the original position that the drag originated from, to its current position.</summary>
            <param name="SquaredDistance">True to retrieve squared distance, to improve performance by avoiding square root computation</param>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.BaseMouseDraggedEventArgs.SetHandled``1(``0,System.Boolean)">
            <summary>This is currently not implemented - it does nothing.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDragEndEventArgs.IsLMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDragEndEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDragEndEventArgs.IsRMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDragEndEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.BaseMouseDragEndEventArgs.IsMMB">
            <summary>True if the <see cref="P:MGUI.Shared.Input.Mouse.BaseMouseDragEndEventArgs.Button"/> associated with this event is <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/></summary>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.BaseMouseDragEndEventArgs.GetTotalDistanceMoved(System.Boolean)">
            <summary>Returns the distance the mouse has moved from the original position that the drag originated from, to its current position.</summary>
            <param name="SquaredDistance">True to retrieve squared distance, to improve performance by avoiding square root computation</param>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.BaseMouseDragEndEventArgs.SetHandled``1(``0,System.Boolean)">
            <summary>This is currently not implemented - it does nothing.</summary>
        </member>
        <member name="F:MGUI.Shared.Input.Mouse.DragStartCondition.MousePressed">
            <summary>The <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.DragStart"/> event will be invoked immediately after the mouse has been pressed inside the viewport.</summary>
        </member>
        <member name="F:MGUI.Shared.Input.Mouse.DragStartCondition.MouseMovedAfterPress">
            <summary>The <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.DragStart"/> event will be invoked after the mouse has moved by at least <see cref="P:MGUI.Shared.Input.Mouse.MouseTracker.DragThreshold"/> number of pixels, after being pressed inside the viewport.</summary>
        </member>
        <member name="F:MGUI.Shared.Input.Mouse.DragStartCondition.Both">
            <summary>The <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.DragStart"/> event will be invoked immediately after the mouse has been pressed inside the viewport<br/>
            AND again after the mouse has moved by at least <see cref="P:MGUI.Shared.Input.Mouse.MouseTracker.DragThreshold"/> number of pixels, after being pressed inside the viewport.<para/>
            Highly recommended to avoid using this value, only intended for specialized use-cases.</summary>
        </member>
        <member name="T:MGUI.Shared.Input.Mouse.MouseHandler">
            <summary>Exposes several mouse-related events that you can subscribe and respond to, such as <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.Entered"/>, <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.Dragged"/>, <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.LMBPressedInside"/> etc.<para/>
            This class is instantiated via: <see cref="M:MGUI.Shared.Input.Mouse.MouseTracker.CreateHandler``1(``0,System.Nullable{System.Double},System.Boolean,System.Boolean,System.Boolean)"/></summary>
        </member>
        <member name="F:MGUI.Shared.Input.Mouse.MouseHandler.DragStartConditions">
            <summary>Only includes distinct values. Does not include combined values such as <see cref="F:MGUI.Shared.Input.Mouse.DragStartCondition.Both"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.AlwaysHandlesEvents">
            <summary>If true, <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.HandledBy"/> will always be set to <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/> after invoking an event.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.InvokeEvenIfHandled">
            <summary>If true, events will still be invoked even if <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> is true.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.InvokeIfHandledBySelf">
            <summary>If true, events will still be invoked even if <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> is true, 
            as long as the handler is the same as <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.IsHovered">
            <summary>True if the mouse is currently inside the viewport</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.Scrolled">
            <summary>Invoked when the mouse wheel is scrolled overtop of the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.MovedInside">
            <summary>Invoked when the mouse moves to a different position, and that position is inside of the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.MovedOutside">
            <summary>Invoked when the mouse moves to a different position, and that position is outside of the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.Entered">
            <summary>Invoked when the mouse enters the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.Exited">
            <summary>Invoked when the mouse exits the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.PressedInside">
            <summary>Invoked when any <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is pressed while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.LMBPressedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/> is pressed while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.MMBPressedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/> is pressed while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.RMBPressedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/> is pressed while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.PressedOutside">
            <summary>Invoked when any <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is pressed while the mouse is currently outside of the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.ReleasedInside">
            <summary>Invoked when any <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is released while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.LMBReleasedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/> is released while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.MMBReleasedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/> is released while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.RMBReleasedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/> is released while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.ReleasedOutside">
            <summary>Invoked when any <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is released while the mouse is currently outside of the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.ClickedInside">
            <summary>Invoked when any <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is clicked while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.LMBClickedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Left"/> is clicked while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.MMBClickedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Middle"/> is clicked while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.RMBClickedInside">
            <summary>Invoked when <see cref="F:MGUI.Shared.Input.Mouse.MouseButton.Right"/> is clicked while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.ClickedOutside">
            <summary>Invoked when any <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is clicked while the mouse is currently outside of the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.DragStart">
            <summary>Invoked when any <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is pressed while the mouse is currently inside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.<br/>
            If <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.DragStartCondition"/> is <see cref="F:MGUI.Shared.Input.Mouse.DragStartCondition.MouseMovedAfterPress"/>, then will also verify that the mouse has moved by at least <see cref="P:MGUI.Shared.Input.Mouse.MouseTracker.DragThreshold"/> while pressed before invoking the event.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.DragStartOutside">
            <summary>Invoked when any <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is pressed while the mouse is currently outside the <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/>'s viewport.<br/>
            If <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.DragStartCondition"/> is <see cref="F:MGUI.Shared.Input.Mouse.DragStartCondition.MouseMovedAfterPress"/>, then will also verify that the mouse has moved by at least <see cref="P:MGUI.Shared.Input.Mouse.MouseTracker.DragThreshold"/> while pressed before invoking the event.<para/>
            You should probably subscribe to <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.DragStart"/> instead.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.Dragged">
            <summary>Invoked when <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.DragStart"/> is already in progress, and then the mouse moves.</summary>
        </member>
        <member name="E:MGUI.Shared.Input.Mouse.MouseHandler.DragEnd">
            <summary>Invoked when <see cref="E:MGUI.Shared.Input.Mouse.MouseHandler.DragStart"/> is currently in progress, and then the pressed <see cref="T:MGUI.Shared.Input.Mouse.MouseButton"/> is released.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.HasSubscribedEvents">
            <summary>True if at least one event has been subscribed to.<para/>
            If false, the Update method may return early under the assumption that no further processing is needed.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.IsMonitoringScroll">
            <summary>True if at least one scroll event has been subscribed to</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.IsMonitoringMovement">
            <summary>True if at least one move event has been subscribed to</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.IsMonitoringClicks">
            <summary>True if at least one press/release/click event has been subscribed to</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseHandler.IsMonitoringDrag">
            <summary>True if at least one drag event has been subscribed to</summary>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.MouseHandler.AutoUpdate">
            <summary>Should only be invoked via <see cref="M:MGUI.Shared.Input.Mouse.MouseTracker.UpdateHandlers"/>></summary>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.MouseHandler.ManualUpdate">
            <summary>Should be invoked exactly once per Update tick, but only on <see cref="T:MGUI.Shared.Input.Mouse.MouseHandler"/>s where <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.IsManualUpdate"/> is true.<para/>
            This method will invoke any pending mouse events.</summary>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.MouseHandler.Unsubscribe">
            <summary>Permanently invalidates this <see cref="T:MGUI.Shared.Input.Mouse.MouseHandler"/> so that it will not receive and invoke any further mouse-related events.</summary>
        </member>
        <member name="T:MGUI.Shared.Input.Mouse.MouseHandlerHost">
            <summary>This class is just intended to be a convenient way to create a concrete implementation of <see cref="T:MGUI.Shared.Input.Mouse.IMouseHandlerHost"/></summary>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.IMouseViewport.GetOffset">
            <summary>Retrives an offset that should be added to the real mouse screen position before checking if the position is inside the viewport.<para/>
            For example, if a TextBlock is inside a ScrollViewer that is scrolled to VerticalOffset=100,<br/>
            the viewport Rectangle remains unchanged, but the real mouse position is offseted by +100 along the Y-axis before checking if the position is inside the viewport.</summary>
        </member>
        <member name="T:MGUI.Shared.Input.Mouse.MouseTracker">
            <summary>Detects changes to the mouse state between the previous and current Update ticks, but does not invoke the events. Instead, events are subscribed to and fired by <see cref="T:MGUI.Shared.Input.Mouse.MouseHandler"/>.<br/>
            See: <see cref="M:MGUI.Shared.Input.Mouse.MouseTracker.CreateHandler``1(``0,System.Nullable{System.Double},System.Boolean,System.Boolean,System.Boolean)"/>, <see cref="M:MGUI.Shared.Input.Mouse.MouseTracker.CreateHandler``1(``0,MGUI.Shared.Input.InputUpdatePriority,System.Boolean,System.Boolean)"/><para/>
            This class is automatically instantiated when creating an instance of <see cref="P:MGUI.Shared.Input.Mouse.MouseTracker.InputTracker"/>. See: <see cref="P:MGUI.Shared.Input.InputTracker.Mouse"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.ClickPositionThreshold">
            <summary>The maximum number of pixels that the mouse can move by (in either the X or Y direction) while pressed before releasing for a Click event to be invoked.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.ClickTimeThreshold">
            <summary>The maximum amount of time that can pass between a mouse button press and mouse button release to still be registed as a Click event</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.DragThreshold">
            <summary>The minimum number of pixels that the mouse must move by (in either the X or Y direction) while pressed before the a mouse drag event begins.<para/>
            Only used if <see cref="T:MGUI.Shared.Input.Mouse.DragStartCondition"/> == <see cref="F:MGUI.Shared.Input.Mouse.DragStartCondition.MouseMovedAfterPress"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.Handlers">
            <summary>To create a <see cref="T:MGUI.Shared.Input.Mouse.MouseHandler"/>, use <see cref="M:MGUI.Shared.Input.Mouse.MouseTracker.CreateHandler``1(``0,System.Nullable{System.Double},System.Boolean,System.Boolean,System.Boolean)"/> or <see cref="M:MGUI.Shared.Input.Mouse.MouseTracker.CreateHandler``1(``0,MGUI.Shared.Input.InputUpdatePriority,System.Boolean,System.Boolean)"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.MouseLeftButtonPressedRecently">
            <summary>True if the mouse left button was just pressed during the current update.<para/>
            See also: <see cref="P:MGUI.Shared.Input.Mouse.MouseTracker.MouseLeftButtonReleasedRecently"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.MouseLeftButtonReleasedRecently">
            <summary>True if the mouse left button was just released during the current update.<para/>
            See also: <see cref="P:MGUI.Shared.Input.Mouse.MouseTracker.MouseLeftButtonPressedRecently"/></summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.MouseMovedRecently">
            <summary>True if the mouse position changed between the previous update and the current update.</summary>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.MouseTracker.CreateHandler``1(``0,MGUI.Shared.Input.InputUpdatePriority,System.Boolean,System.Boolean)">
            <param name="UpdatePriority">The priority with which the handler receives mouse events. A higher priority means this handler will have the first chance to receive and handle events.</param>
            <param name="AlwaysHandlesEvents">If true, the handler will always set <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.HandledBy"/> to <paramref name="Owner"/> when receiving the mouse event.</param>
            <param name="InvokeEvenIfHandled">If true, the handler will still receive the mouse event even if <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> is true.</param>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.MouseTracker.CreateHandler``1(``0,System.Nullable{System.Double},System.Boolean,System.Boolean,System.Boolean)">
            <param name="UpdatePriority">The priority with which the handler receives mouse events. A higher priority means this handler will have the first chance to receive and handle events.<para/>
            If null, the caller is expected to manually call <see cref="M:MGUI.Shared.Input.Mouse.MouseHandler.ManualUpdate"/> themselves.<br/>
            If not null, <see cref="M:MGUI.Shared.Input.Mouse.MouseHandler.AutoUpdate"/> will automatically be invoked when updating this <see cref="T:MGUI.Shared.Input.Mouse.MouseTracker"/><para/>
            Minimum Value = 0. Maximum Value = 100. Recommended to use preset values from <see cref="T:MGUI.Shared.Input.InputUpdatePriority"/>.</param>
            <param name="AlwaysHandlesEvents">If true, the handler will always set <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.HandledBy"/> to <paramref name="Owner"/> when receiving the mouse event.</param>
            <param name="InvokeEvenIfHandled">If true, the handler will still receive the mouse event even if <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> is true.</param>
            <param name="InvokeIfHandledBySelf">If true, the handler will still receive the mouse event even if <see cref="P:MGUI.Shared.Input.HandledByEventArgs`1.IsHandled"/> is true, 
            as long as the handler is the same as <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.Owner"/></param>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.CurrentScrollEvent">
            <summary>The mouse scroll event that occurred on the current Update tick, or null if the mouse wheel didn't change between the previous Update tick and the current Update tick.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.CurrentMoveEvent">
            <summary>The mouse move event that occurred on the current Update tick, or null if the mouse position didn't change between the previous Update tick and the current Update tick.</summary>
        </member>
        <member name="F:MGUI.Shared.Input.Mouse.MouseTracker._RecentButtonPressedEvents">
            <summary>The most recent MouseButton Press events that have occurred, even if they occurred on a prior Update tick. These values are set back to null when the button is released.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.RecentButtonPressedEvents">
            <summary>The most recent MouseButton Press events that have occurred, even if they occurred on a prior Update tick. These values are set back to null when the button is released.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.CurrentButtonPressedEvents">
            <summary>The MouseButton Press events that occurred on the current Update tick, or null if the button's <see cref="T:Microsoft.Xna.Framework.Input.ButtonState"/> wasn't just set to <see cref="F:Microsoft.Xna.Framework.Input.ButtonState.Pressed"/> on the current Update tick.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.CurrentButtonReleasedEvents">
            <summary>The MouseButton Release events that occurred on the current Update tick, or null if the button's <see cref="T:Microsoft.Xna.Framework.Input.ButtonState"/> wasn't just set to <see cref="F:Microsoft.Xna.Framework.Input.ButtonState.Released"/> on the current Update tick.</summary>
        </member>
        <member name="F:MGUI.Shared.Input.Mouse.MouseTracker._CurrentButtonClickedEvents">
            <summary>The MouseButton Click events that occurred on the current Update tick, or null if the button didn't just finish clicking on the current Update tick.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.CurrentButtonClickedEvents">
            <summary>The MouseButton Click events that occurred on the current Update tick, or null if the button didn't just finish clicking on the current Update tick.</summary>
        </member>
        <member name="F:MGUI.Shared.Input.Mouse.MouseTracker.RecentDragStartEvents">
            <summary>The most recent DragStart events that have occurred, even if they occurred on a prior Update tick. These values are set back to null when the DragEnd event is detected.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.CurrentDragStartEvents">
            <summary>The Mouse DragStart events that occurred on the current Update tick, or null if a DragStart didn't just occur the current Update tick.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.CurrentDraggedEvents">
            <summary>The Mouse Dragged events that occurred on the current Update tick, or null if a Dragged event didn't just occur the current Update tick.</summary>
        </member>
        <member name="P:MGUI.Shared.Input.Mouse.MouseTracker.CurrentDragEndEvents">
            <summary>The Mouse DragEnd events that occurred on the current Update tick, or null if a DragEnd didn't just occur the current Update tick.</summary>
        </member>
        <member name="M:MGUI.Shared.Input.Mouse.MouseTracker.UpdateHandlers">
            <summary>Should be invoked exactly once per Update tick.<para/>
            This method will invoke any pending mouse events on its <see cref="P:MGUI.Shared.Input.Mouse.MouseTracker.Handlers"/> where <see cref="P:MGUI.Shared.Input.Mouse.MouseHandler.IsManualUpdate"/> is false.</summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.BlendType.Default">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.BlendState.AlphaBlend"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.BlendType.Additive">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.BlendState.Additive"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.BlendType.AlphaBlend">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.BlendState.AlphaBlend"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.BlendType.NonPremultiplied">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.BlendState.NonPremultiplied"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.BlendType.Opaque">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.BlendState.Opaque"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.SamplerType.Default">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.SamplerState.LinearClamp"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.SamplerType.AnisotropicClamp">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.SamplerState.AnisotropicClamp"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.SamplerType.AnisotropicWrap">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.SamplerState.AnisotropicWrap"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.SamplerType.LinearClamp">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.SamplerState.LinearClamp"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.SamplerType.LinearWrap">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.SamplerState.LinearWrap"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.SamplerType.PointClamp">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.SamplerState.PointClamp"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.SamplerType.PointWrap">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.SamplerState.PointWrap"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.DepthStencilType.Default">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.DepthStencilState.None"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.DepthStencilType.DepthRead">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.DepthStencilState.DepthRead"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.DepthStencilType.None">
            <summary><see cref="F:Microsoft.Xna.Framework.Graphics.DepthStencilState.None"/></summary>
        </member>
        <member name="T:MGUI.Shared.Rendering.DrawSettings">
            <summary>Stores settings used by <see cref="M:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable{Microsoft.Xna.Framework.Matrix})"/></summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawSettings.#ctor(Microsoft.Xna.Framework.Matrix,MGUI.Shared.Rendering.RasterizerType,Microsoft.Xna.Framework.Graphics.SpriteSortMode,MGUI.Shared.Rendering.BlendType,MGUI.Shared.Rendering.SamplerType,MGUI.Shared.Rendering.DepthStencilType)">
            <summary>Stores settings used by <see cref="M:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable{Microsoft.Xna.Framework.Matrix})"/></summary>
        </member>
        <member name="P:MGUI.Shared.Rendering.DrawTransaction.WhitePixel">
            <summary>A solid white, 1 pixel wide/tall Texture. Useful for drawing Colored squares. 
            (Color can be specified in the 'Color' mask parameter of SpriteBatch.Draw(...))</summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.#ctor(MGUI.Shared.Rendering.MainRenderer,MGUI.Shared.Rendering.DrawSettings,System.Boolean,MGUI.Shared.Rendering.DrawContext)">
            <param name="Settings">See also: <see cref="P:MGUI.Shared.Rendering.DrawSettings.Default"/></param>
            <param name="DeferBegin">If true, <see cref="M:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable{Microsoft.Xna.Framework.Matrix})"/> or <see cref="M:MonoGame.Extended.VectorDraw.PrimitiveBatch.Begin(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Matrix@)"/><para/>
            will not be invoked until you call a draw-related function within <see cref="T:MGUI.Shared.Rendering.DrawTransaction"/>, such as <see cref="M:MGUI.Shared.Rendering.DrawTransaction.DrawTextureTo(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Rectangle)"/></param>
            <param name="DefaultContext">Only relevant if <paramref name="DeferBegin"/>==false. The default drawing context to immediately start.</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.ForceBeginDraw(MGUI.Shared.Rendering.DrawContext)">
            <summary>Should only be invoked if you intend to make a draw-related call that isn't already funneled through <see cref="T:MGUI.Shared.Rendering.DrawTransaction"/>.<para/>
            Draw-related calls that are funneled through <see cref="T:MGUI.Shared.Rendering.DrawTransaction"/> (such as <see cref="M:MGUI.Shared.Rendering.DrawTransaction.StrokeRectangle(Microsoft.Xna.Framework.Vector2,MonoGame.Extended.RectangleF,Microsoft.Xna.Framework.Color,MonoGame.Extended.Thickness,System.Nullable{MGUI.Shared.Rendering.DrawContext})"/>) will already call the begin methods if necessary.</summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawTextureTo(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Rectangle)">
            <summary>Draw a texture to a given <paramref name="Destination"/> <see cref="T:Microsoft.Xna.Framework.Rectangle"/></summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawTextureTo(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Color)">
            <summary>Draw a texture to a given <paramref name="Destination"/> <see cref="T:Microsoft.Xna.Framework.Rectangle"/></summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawTextureTo(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects)">
            <summary>Draw a texture to a given <paramref name="Destination"/> <see cref="T:Microsoft.Xna.Framework.Rectangle"/></summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawTextureAt(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Vector2)">
            <summary>Draw a texture at a given <paramref name="Destination"/> point</summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawTextureAt(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)">
            <summary>Draw a texture at a given <paramref name="Destination"/> point</summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawTextureAt(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects)">
            <summary>Draw a texture at a given <paramref name="Destination"/> point</summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawShadowedText(System.String,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,System.Int32,System.Single,System.Single,System.Boolean)">
            <param name="Family">The font to use</param>
            <param name="DesiredFontSize">The desired size of the <see cref="T:Microsoft.Xna.Framework.Graphics.SpriteFont"/>, in points.</param>
            <param name="Exact">If true, will attempt to render the text at exactly the given <paramref name="DesiredFontSize"/>.<br/>
            If false, treats <paramref name="DesiredFontSize"/> as an approximation, and may render the text slightly larger or smaller to avoid blurriness</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawShadowedText(System.String,MGUI.Shared.Text.CustomFontStyles,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,System.Int32,System.Single,System.Single,System.Boolean)">
            <param name="Family">The font to use</param>
            <param name="DesiredFontSize">The desired size of the <see cref="T:Microsoft.Xna.Framework.Graphics.SpriteFont"/>, in points.</param>
            <param name="Exact">If true, will attempt to render the text at exactly the given <paramref name="DesiredFontSize"/>.<br/>
            If false, treats <paramref name="DesiredFontSize"/> as an approximation, and may render the text slightly larger or smaller to avoid blurriness</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawText(System.String,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Int32,System.Boolean)">
            <summary>Renders the given <paramref name="Text"/> using <see cref="F:MGUI.Shared.Text.CustomFontStyles.Normal"/> style.</summary>
            <param name="Family">The font to use</param>
            <param name="DesiredFontSize">The desired size of the <see cref="T:Microsoft.Xna.Framework.Graphics.SpriteFont"/>, in points.</param>
            <param name="Exact">If true, will attempt to render the text at exactly the given <paramref name="DesiredFontSize"/>.<br/>
            If false, treats <paramref name="DesiredFontSize"/> as an approximation, and may render the text slightly larger or smaller to avoid blurriness</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.DrawText(System.String,MGUI.Shared.Text.CustomFontStyles,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Int32,System.Boolean)">
            <param name="Family">The font to use</param>
            <param name="DesiredFontSize">The desired size of the <see cref="T:Microsoft.Xna.Framework.Graphics.SpriteFont"/>, in points.</param>
            <param name="Exact">If true, will attempt to render the text at exactly the given <paramref name="DesiredFontSize"/>.<br/>
            If false, treats <paramref name="DesiredFontSize"/> as an approximation, and may render the text slightly larger or smaller to avoid blurriness</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.GetFirstValidDrawContext(System.Nullable{MGUI.Shared.Rendering.DrawContext}[])">
            <summary>Returns the first non-null, non-None <see cref="T:MGUI.Shared.Rendering.DrawContext"/> from given <paramref name="Values"/></summary>
        </member>
        <member name="F:MGUI.Shared.Rendering.DrawTransaction.CircleMaxSides">
            <summary>The maximum number of edges to use when approximating the geometry of a circle.<para/>
            This value is arbitrarily chosen to maintain reasonable performance and it's unlikely that a circle will ever be drawn with this many sides.</summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.StrokeAndFillCircle(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,System.Single,System.Single,System.Int32,System.Nullable{MGUI.Shared.Rendering.DrawContext})">
            <param name="NumSides">How many sides to use when approximating the geometry of the circle. Recommended: 16-32. Max value = <see cref="F:MGUI.Shared.Rendering.DrawTransaction.CircleMaxSides"/></param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.StrokeCircle(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,System.Single,System.Int32,System.Nullable{MGUI.Shared.Rendering.DrawContext})">
            <param name="NumSides">How many sides to use when approximating the geometry of the circle. Recommended: 16-32. Max value = <see cref="F:MGUI.Shared.Rendering.DrawTransaction.CircleMaxSides"/></param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.FillCircle(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,System.Int32,System.Nullable{MGUI.Shared.Rendering.DrawContext})">
            <param name="NumSides">How many sides to use when approximating the geometry of the circle. Recommended: 16-32. Max value = <see cref="F:MGUI.Shared.Rendering.DrawTransaction.CircleMaxSides"/></param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.StrokePolygon(Microsoft.Xna.Framework.Vector2,System.Collections.Generic.IReadOnlyList{Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Color,System.Single,System.Boolean,System.Nullable{MonoGame.Extended.Triangulation.WindingOrder},System.Nullable{MGUI.Shared.Rendering.DrawContext})">
            <param name="CenterLinesOnVertices">If true, the <paramref name="Vertices"/> will represent the center of the line strokes. (I.E. the stroke will extend left of the vertex by half the <paramref name="Thickness"/>, and right of the vertex by half the <paramref name="Thickness"/>)<br/>
            If false, the <paramref name="Vertices"/> will represent the outer portion of the line strokes, meaning that the line stroke will extend inwards towards the center of the polygon by the <paramref name="Thickness"/> amount.</param>
            <param name="Order">The <see cref="T:MonoGame.Extended.Triangulation.WindingOrder"/> of the <paramref name="Vertices"/>.<para/>
            Will be dynamically computed if null. (Only used if <paramref name="CenterLinesOnVertices"/> is false)</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.FillQuadrilateralLinearClamp(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)">
            <summary>Fills the given quadrilateral using <see cref="F:MGUI.Shared.Rendering.SamplerType.LinearClamp"/> to produce gradient color interpolation.</summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.SetRenderTarget(Microsoft.Xna.Framework.Graphics.RenderTarget2D,System.Nullable{Microsoft.Xna.Framework.Color})">
            <param name="ClearColor">Optional. If not null, the new render target will be immediately cleared with this color. Only used if the render target actually changed.</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.SetRenderTargetTemporary(Microsoft.Xna.Framework.Graphics.RenderTarget2D,System.Nullable{Microsoft.Xna.Framework.Color})">
            <summary>
            Drawing to a temporary render target example:<para/>
            <code xml:space="preserve">
            <see cref="T:Microsoft.Xna.Framework.Graphics.RenderTarget2D"/> Temp = <see cref="M:MGUI.Shared.Helpers.RenderUtils.CreateRenderTarget(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Rectangle,System.Boolean)"/>;<br/>
            using (Temp)<br/>
            {<br/>
            using (<see cref="M:MGUI.Shared.Rendering.DrawTransaction.SetRenderTargetTemporary(Microsoft.Xna.Framework.Graphics.RenderTarget2D,System.Nullable{Microsoft.Xna.Framework.Color})"/>)<br/>
            {<br/>
            //Draw something<br/>
            }<para/>
            //  Optionally, draw the temporary render target to the backbuffer<br/>
            <see cref="M:MGUI.Shared.Rendering.DrawTransaction.DrawTextureAt(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Vector2)"/>;<br/>
            }</code>
            </summary>
            <param name="ClearColor">Optional. If not null, the new render target will be immediately cleared with this color. Only used if the render target actually changed.</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.SetDrawSettings(MGUI.Shared.Rendering.DrawSettings)">
            <param name="New">To change current settings, consider using '<see cref="P:MGUI.Shared.Rendering.DrawTransaction.CurrentSettings"/> with { ... }' record syntax.</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.SetDrawSettingsTemporary(MGUI.Shared.Rendering.DrawSettings)">
            <param name="New">To change current settings, consider using '<see cref="P:MGUI.Shared.Rendering.DrawTransaction.CurrentSettings"/> with { ... }' record syntax.</param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.SetClipTarget(System.Nullable{Microsoft.Xna.Framework.Rectangle},System.Boolean)">
            <param name="IntersectWithCurrentClipTarget">If true, rather than replacing the clip target with the given <paramref name="Bounds"/>,<br/>
            the clip target will be the intersection of the current clip target and the given <paramref name="Bounds"/></param>
        </member>
        <member name="M:MGUI.Shared.Rendering.DrawTransaction.SetClipTargetTemporary(System.Nullable{Microsoft.Xna.Framework.Rectangle},System.Boolean)">
            <param name="IntersectWithCurrentClipTarget">If true, rather than replacing the clip target with the given <paramref name="Bounds"/>,<br/>
            the clip target will be the intersection of the current clip target and the given <paramref name="Bounds"/></param>
        </member>
        <member name="M:MGUI.Shared.Rendering.IRenderViewport.GetBounds">
            <summary>The valid bounds of this viewport, relative to the topleft corner of the <see cref="T:Microsoft.Xna.Framework.GameWindow"/>.<para/>
            To allow rendering content to the entire <see cref="T:Microsoft.Xna.Framework.GameWindow"/>, 
            use a <see cref="T:Microsoft.Xna.Framework.Rectangle"/> with Left=0, Top=0, Width=<see cref="P:Microsoft.Xna.Framework.GameWindow.ClientBounds"/>.Width, Height=<see cref="P:Microsoft.Xna.Framework.GameWindow.ClientBounds"/>.Height</summary>
        </member>
        <member name="E:MGUI.Shared.Rendering.IObservableUpdate.PreviewUpdate">
            <summary>The <see cref="T:System.TimeSpan"/> represents the total elapsed time.<para/>
            See also: <see cref="P:Microsoft.Xna.Framework.GameTime.TotalGameTime"/></summary>
        </member>
        <member name="T:MGUI.Shared.Rendering.IRenderHost">
            <summary>For a concrete implementation, consider using <see cref="T:MGUI.Shared.Rendering.GameRenderHost`1"/></summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.MainRenderer.#ctor(MGUI.Shared.Rendering.IRenderHost)">
            <param name="Host">Consider using an instance of <see cref="T:MGUI.Shared.Rendering.GameRenderHost`1"/> to quickly create an implementation of <see cref="T:MGUI.Shared.Rendering.IRenderHost"/></param>
        </member>
        <member name="M:MGUI.Shared.Rendering.MainRenderer.GetOrCreateWhiteCircleTexture(System.Single,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Returns a circle texture whose radius is at least as big as <paramref name="DesiredRadius"/>.<para/>
            Attempts to round <paramref name="DesiredRadius"/> up to the nearest power of 2 to prevent generating too many textures.</summary>
            <param name="MinimumRadius">If null, uses <see cref="M:System.Math.Floor(System.Double)"/> of <paramref name="DesiredRadius"/>.<para/>
            The absolute minimum radius used is <see cref="F:MGUI.Shared.Rendering.MainRenderer.MinimumCircleTextureRadius"/></param>
            <param name="MaximumRadius">If null, uses <see cref="M:MGUI.Shared.Helpers.GeneralUtils.NextPowerOf2(System.Single)"/> of <paramref name="DesiredRadius"/>.<para/>
            The absolute maximum radius used is <see cref="F:MGUI.Shared.Rendering.MainRenderer.MaximumCircleTextureRadius"/></param>
        </member>
        <member name="P:MGUI.Shared.Rendering.View.ScreenViewport">
            <summary>The entire screen bound's that this <see cref="T:MGUI.Shared.Rendering.View"/> occupies.</summary>
        </member>
        <member name="M:MGUI.Shared.Rendering.View.SetScreenViewportBase(Microsoft.Xna.Framework.Rectangle,System.Action,System.Boolean)">
            <param name="NotifyChanged">True if <see cref="E:MGUI.Shared.Rendering.View.OnScreenViewportChanged"/> should be invoked.</param>
            <param name="BeforeNotify">Optional, can be null. If not null, this action will be invoked after <see cref="P:MGUI.Shared.Rendering.View.ScreenViewport"/> is set to the new <paramref name="Value"/>, but before <see cref="E:MGUI.Shared.Rendering.View.OnScreenViewportChanged"/> is invoked.</param>
        </member>
        <member name="E:MGUI.Shared.Rendering.View.OnBeginUpdate">
            <summary>Invoked at the beginning of the <see cref="M:MGUI.Shared.Rendering.View.Update(MGUI.Shared.Rendering.UpdateBaseArgs)"/> method.</summary>
        </member>
        <member name="E:MGUI.Shared.Rendering.View.OnEndUpdate">
            <summary>Invoked at the end of the <see cref="M:MGUI.Shared.Rendering.View.Update(MGUI.Shared.Rendering.UpdateBaseArgs)"/> method.</summary>
        </member>
        <member name="P:MGUI.Shared.Text.FontManager.DefaultFontFamily">
            <summary>The name of the font family that should be used by default when no font has been explicitly specified for text content.</summary>
        </member>
        <member name="M:MGUI.Shared.Text.FontManager.TryGetFont(System.String,MGUI.Shared.Text.CustomFontStyles,System.Int32,System.Boolean,MGUI.Shared.Text.FontSet@,Microsoft.Xna.Framework.Graphics.SpriteFont@,System.Int32@,System.Single@,System.Single@)">
            <param name="DesiredFontSize">The desired height, in points, of the returned <see cref="T:Microsoft.Xna.Framework.Graphics.SpriteFont"/> <paramref name="SF"/></param>
            <param name="PreferDownsampled">If true, will attempt to retrieve a font size that is approximately twice as large as the <paramref name="DesiredFontSize"/>, and scale it down by approximately 0.5</param>
            <param name="ExactScale">The scale factor that must be applied to the returned <see cref="T:Microsoft.Xna.Framework.Graphics.SpriteFont"/> <paramref name="SF"/> to make it have the desired <paramref name="DesiredFontSize"/></param>
            <param name="SuggestedScale">Recommended scale factor that might not result in the exact value for <paramref name="DesiredFontSize"/>, but will result in sharper, less blurred text.</param>
        </member>
        <member name="T:MGUI.Shared.Text.FontSet">
            <summary>Represents a collection of fonts belonging to the same family. This is usually several different sizes and FontStyles (Bold, Italics etc) of the same font.</summary>
        </member>
        <member name="P:MGUI.Shared.Text.FontSet.Name">
            <summary>EX: "Arial". Doesn't include suffixes such as "Arial Bold"</summary>
        </member>
        <member name="M:MGUI.Shared.Text.FontSet.#ctor(Microsoft.Xna.Framework.Content.ContentManager,System.String)">
            <summary>Generates a <see cref="T:MGUI.Shared.Text.FontSet"/> from all .xnb files found in:<br/>
            <code>{ExeFolder}\{Content.RootDirectory}\Fonts\{FontName}\</code><para/>
            where the .xnb's filename is in the following format:<br/>
            <code>{FontSize}_{Underscore-Delimited-FontStyles}.xnb</code><para/>
            Example format:<br/>
            {ExeFolder}\Content\Fonts\Arial\10_Bold.xnb - Represents a SpriteFont where Size=10pts for the 'Arial Bold' Font Family.<br/>
            {ExeFolder}\Content\Fonts\Calibri\12_Bold_Italic.xnb - Represents a SpriteFont where Size=12pts for the 'Calibri Bold Italic' Font Family.<br/>
            {ExeFolder}\Content\Fonts\Helvetica\14_Normal.xnb - Represents a SpriteFont where Size=14pts for the 'Helvetica' Font Family.<para/>
            Supported FontStyles: <see cref="F:MGUI.Shared.Text.CustomFontStyles.Normal"/>, <see cref="F:MGUI.Shared.Text.CustomFontStyles.Bold"/>, <see cref="F:MGUI.Shared.Text.CustomFontStyles.Italic"/><para/>
            To programmatically generate .spritefont files in the desired file name format, consider using:<br/>
            <see cref="M:MGUI.Shared.Text.SpritefontGenerator.GenerateDefault(Microsoft.Xna.Framework.Content.ContentManager,System.String)"/><br/>
            and then adding the generated .spritefont files to your MonoGame Content</summary>
        </member>
        <member name="M:MGUI.Shared.Text.FontSet.TryGetFont(MGUI.Shared.Text.CustomFontStyles,System.Int32,System.Boolean,Microsoft.Xna.Framework.Graphics.SpriteFont@,System.Int32@,System.Single@,System.Single@)">
            <param name="DesiredFontSize">The desired height, in points, of the returned <see cref="T:Microsoft.Xna.Framework.Graphics.SpriteFont"/> <paramref name="Result"/></param>
            <param name="PreferDownsampled">If true, will attempt to retrieve a font size that is approximately twice as large as the <paramref name="DesiredFontSize"/>, and scale it down by approximatly 0.5</param>
            <param name="ExactScale">The scale factor that must be applied to the returned <see cref="T:Microsoft.Xna.Framework.Graphics.SpriteFont"/> <paramref name="Result"/> to make it have the desired <paramref name="DesiredFontSize"/></param>
            <param name="SuggestedScale">Recommended scale factor that might not result in the exact value for <paramref name="DesiredFontSize"/>, but will result in sharper, less blurred text.</param>
        </member>
        <member name="M:MGUI.Shared.Text.SpritefontGenerator.GenerateDefault(Microsoft.Xna.Framework.Content.ContentManager,System.String)">
            <summary>Invokes <see cref="M:MGUI.Shared.Text.SpritefontGenerator.Generate(Microsoft.Xna.Framework.Content.ContentManager,System.String,System.Collections.Generic.IEnumerable{MGUI.Shared.Text.SpritefontStyle},System.Collections.Generic.IEnumerable{System.Int32})"/> with default settings for font styles and sizes.</summary>
        </member>
        <member name="M:MGUI.Shared.Text.SpritefontGenerator.Generate(Microsoft.Xna.Framework.Content.ContentManager,System.String,System.Collections.Generic.IEnumerable{MGUI.Shared.Text.SpritefontStyle},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Creates several .spritefont files in {ExeFolder}\{Content.RootDirectory}\Fonts\{FontName}, one file for each permutation of <paramref name="FontStyles"/> and <paramref name="FontSizes"/><para/>
            The files will be named in the following format:<br/>
            <code>{FontSize}_{Underscore-Delimited-FontStyles}.xnb</code><para/>
            Example format:<br/>
            {ExeFolder}\Content\Fonts\Arial\10_Bold.xnb - Represents a SpriteFont where Size=10pts for the 'Arial Bold' Font Family.<br/>
            {ExeFolder}\Content\Fonts\Calibri\12_Bold_Italic.xnb - Represents a SpriteFont where Size=12pts for the 'Calibri Bold Italic' Font Family.<br/>
            {ExeFolder}\Content\Fonts\Helvetica\14_Normal.xnb - Represents a SpriteFont where Size=14pts for the 'Helvetica' Font Family.</summary>
            <param name="FontName">The base name of the font, such as 'Arial' or 'Times New Roman'. This value should not include any suffixes related to the font's style (like 'Arial Bold')</param>
            <param name="FontStyles">The font styles to generate a .spritefont file for.</param>
            <param name="FontSizes">The font sizes (in points) to generate a .spritefont file for.</param>
        </member>
    </members>
</doc>
